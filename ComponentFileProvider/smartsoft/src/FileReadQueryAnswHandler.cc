//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2015 Matthias Lutz
//
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "FileReadQueryAnswHandler.hh"
#include "ComponentFileProvider.hh"
#include <iostream>
#include <fstream>
#include <boost/filesystem.hpp>
#include <zlib.h>
FileReadQueryAnswHandler::FileReadQueryAnswHandler(Smart::IQueryServerPattern<CommBasicObjects::CommFileReadRequest, CommBasicObjects::CommFileReadAnswer>* server)
:	FileReadQueryAnswHandlerCore(server)
{
	
}

FileReadQueryAnswHandler::~FileReadQueryAnswHandler()
{
	
}


void FileReadQueryAnswHandler::handleQuery(const Smart::QueryIdPtr &id, const CommBasicObjects::CommFileReadRequest& request)
{
	CommBasicObjects::CommFileReadAnswer answer;
	
	// implement your query handling logic here and fill in the answer object


		std::cout<<"[FileRead] File Read Query: "<<request.getFilename()<<std::endl;


		CommBasicObjects::CommDataFiles files;
		files.setTimestamp(CommBasicObjects::CommTimeStamp::now());
		files.setBaseFileName(request.getFilename());

		try{
			boost::filesystem::path path(request.getFilename());
			if(boost::filesystem::exists(path)){
				if(boost::filesystem::is_regular_file(path)){

					std::cout<<"[FileRead] SINGLE file, size: "<<boost::filesystem::file_size(path)<<std::endl;

					std::ifstream fin(path.c_str(), std::ios::in | std::ifstream::binary);
					if(fin){
						fin.seekg(0, std::ios::end);
						std::streamsize fileSize = fin.tellg();
						fin.seekg(0, std::ios::beg);

						CommBasicObjects::CommFileMetaData meta;
						//remove the paths from the single file!
						meta.setFilename(path.filename().string());
						meta.setFilesize(fileSize);
						meta.setFiletype(CommBasicObjects::FileType::FILE_REGULAR);

						files.setIsSingleFile(true);
						files.pushBackfileMetaData(meta);

						files.resizeDatastream(fileSize);

						if (fin.read(files.getDatastreamRef().data(), fileSize))
						{
							std::cout<<"[FileRead] Success reading file!"<<std::endl;
							files.setValid(true);
							//answer.setFile(files);
							answer.setSuccess(true);
						} else {
							std::cout<<"[FileRead] Error reading file!"<<std::endl;
							answer.setSuccess(false);
						}
						fin.close();

					} else {
						std::cout << "[FileRead] Error could not open " << request.getFilename() << "\n";
						answer.setSuccess(false);
					}

				} else if(boost::filesystem::is_directory(path)){
					std::cout<<"[FileRead] Directory file - Copy all content!"<<std::endl;
					boost::filesystem::recursive_directory_iterator iter(path), end;
					for(;iter != end; ++iter)
					{
						std::cout<<"[FileRead] File: "<<iter->path();
						if(boost::filesystem::is_regular_file(iter->path())){
							std::ifstream fin(iter->path().c_str(), std::ios::in | std::ifstream::binary);
							if(fin){
								fin.seekg(0, std::ios::end);
								std::streamsize fileSize = fin.tellg();
								fin.seekg(0, std::ios::beg);
								std::cout<<" file, size: "<<fileSize<<std::endl;


								CommBasicObjects::CommFileMetaData meta;
								//remove the base path from the files
								meta.setFilename(iter->path().string().substr(request.getFilename().size(),iter->path().string().size()));
								meta.setFilesize(fileSize);
								meta.setFiletype(CommBasicObjects::FileType::FILE_REGULAR);

								files.pushBackfileMetaData(meta);

								std::streamsize lastPose = files.getDatastreamSize();

								files.resizeDatastream(files.getDatastreamSize()+fileSize);

								if (!fin.read(files.getDatastreamRef().data()+lastPose, fileSize))
								{
									std::cout<<"[FileRead] Error reading file!"<<std::endl;
									answer.setSuccess(false);
									std::cout<<" DONE - [FileRead] File read from disk --> sending answer"<<std::endl;
									this->server->answer(id, answer);
									fin.close();
									return;
								} else {
									std::cout<<"[FileRead] Success reading file!"<<std::endl;
								}
								fin.close();
							} else {
								std::cout << "[FileRead] Error could not open " << iter->path().c_str() << "\n";
								answer.setSuccess(false);
								std::cout<<" DONE - [FileRead] File read from disk --> sending answer"<<std::endl;
								this->server->answer(id, answer);
								return;
							}

						} else if(boost::filesystem::is_directory(iter->path())){
							std::cout<<" is directory no read only push meta data!"<<std::endl;
							CommBasicObjects::CommFileMetaData meta;
							std::string full_file(iter->path().string());
							meta.setFilename(full_file.substr(request.getFilename().size(),full_file.size()));
							meta.setFilesize(0);
							meta.setFiletype(CommBasicObjects::FileType::FILE_DIRECTORY);
							files.pushBackfileMetaData(meta);
						}
					}

					files.setValid(true);
					answer.setSuccess(true);
					files.setIsSingleFile(false);


				} else {
					std::cout << "[FileRead] File is not a regular file or directory\n"<<std::endl;
					answer.setSuccess(false);
				}

			} else {
				std::cout << "[FileRead] Error could not open " << request.getFilename() << "File does not exist!" <<"\n";
				answer.setSuccess(false);
			}

			//TODO this could be done above with the need to copy the data twice!
			if(request.getCompressFile()==true && answer.getSuccess()==true){
				std::cout<<"[FileRead] Compression streamsize: "<<files.getDatastreamSize()<<std::endl;
				long unsigned int maxSize =  compressBound(files.getDatastreamSize());
				unsigned char * buffer =  (unsigned char *) malloc(maxSize);
				long unsigned int realSize = files.getDatastreamSize();
				unsigned char * source = reinterpret_cast<unsigned char*>(files.getDatastreamRef().data());

				if(Z_OK == compress(buffer,&maxSize,source ,realSize)){
					std::cout<<"[FileRead] Compression OK new size: "<<maxSize<<std::endl;

					files.resizeDatastream(maxSize);
					memcpy(files.getDatastreamRef().data(),buffer,maxSize);
					free(buffer);
					files.setCommpression(true);
				} else {
					std::cout<<"[FileRead] Error Compressing File --> sending files uncompressed!"<<std::endl;
					files.setCommpression(false);
				}
			}
			answer.setFile(files);


		}
		catch (const boost::filesystem::filesystem_error& ex)
		{
			std::cout << ex.what() << '\n';
		}
		catch (...) {
			std::cout << "[FileRead] Catch(...) Could not open " << request.getFilename() << "\n";
			answer.setSuccess(false);
		}

		std::cout<<"[FileRead] DONE - File read(s) from disk --> sending answer fullStreamsize: "<<files.getDatastreamSize()<<std::endl;


	this->server->answer(id, answer);
}
