//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2015 Matthias Lutz
//
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "FileWriteQueryAnswHandler.hh"
#include "ComponentFileProvider.hh"
#include <iostream>
#include <boost/filesystem.hpp>
#include <zlib.h>
FileWriteQueryAnswHandler::FileWriteQueryAnswHandler(Smart::IQueryServerPattern<CommBasicObjects::CommFileWriteRequest, CommBasicObjects::CommFileWriteAnswer>* server)
:	FileWriteQueryAnswHandlerCore(server)
{
	
}

FileWriteQueryAnswHandler::~FileWriteQueryAnswHandler()
{
	
}


void FileWriteQueryAnswHandler::handleQuery(const Smart::QueryIdPtr &id, const CommBasicObjects::CommFileWriteRequest& request)
{
	CommBasicObjects::CommFileWriteAnswer answer;
	
	// implement your query handling logic here and fill in the answer object

		CommBasicObjects::CommDataFiles file = request.getFile();
		std::vector<CommBasicObjects::CommFileMetaData> meta = file.getFileMetaDataCopy();

		std::cout<<"[FileWrite] File Write Query target file: "<<request.getFilename()<<" fullStreamsize: "<<file.getDatastreamSize()<<std::endl;


		if(file.getCommpression()==true){
			std::cout<<"[FileWrite] Stream is compressed! "<<std::endl;
			long unsigned int maxSize = 0;
			for(unsigned int i=0; i<meta.size();++i){
				maxSize += meta[i].getFilesize();
			}
			unsigned char * buffer =  (unsigned char *) malloc(maxSize);

			long unsigned int sourceSize = file.getDatastreamSize();
			unsigned char * source = reinterpret_cast<unsigned char*>(file.getDatastreamRef().data());

			if(Z_OK == uncompress(buffer,&maxSize,source,sourceSize)){
				std::cout<<"[FileWrite] Compression OK new size: "<<maxSize<<std::endl;
				file.resizeDatastream(maxSize);
				memcpy(file.getDatastreamRef().data(),buffer,maxSize);
				free(buffer);
			} else {
				std::cout<<" DONE - [FileWrite] Error Compressing File!"<<std::endl;
				answer.setSuccess(false);
				this->server->answer(id, answer);
				return;
			}
		}

		if(file.getValid() == true){
			try{
				boost::filesystem::path newBasePath(request.getFilename());

				//in case of dir copy create the taget dir if not existing
				if(file.getIsSingleFile() == false){
					std::cout<<"[FileWrite] create target dir: "<<newBasePath<<std::endl;
					if(boost::filesystem::create_directories(newBasePath)){
						std::cout<<"[FileWrite] create_directories - OK"<<std::endl;
					} else {
						std::cout<<"[FileWrite] create_directories - FALSE"<<std::endl;
					}
				}

				//First create directories of the request if any
				for(unsigned int i=0; i<meta.size();++i){
					if(meta[i].getFiletype() == CommBasicObjects::FileType::FILE_DIRECTORY){
						boost::filesystem::path dir(meta[i].getFilename());
						std::cout<<"[FileWrite] Create Directory: "<< newBasePath/dir <<std::endl;
						if(boost::filesystem::create_directories(newBasePath/dir)){
							std::cout<<"[FileWrite] create_directories - OK"<<std::endl;
						} else {
							std::cout<<"[FileWrite] create_directories - FALSE"<<std::endl;
						}
					}
				}


				std::streamsize lastFile = 0;

				for(unsigned int i=0; i<meta.size();++i){

					if(meta[i].getFiletype() == CommBasicObjects::FileType::FILE_REGULAR){
						boost::filesystem::path newFilePath;

						if(file.getIsSingleFile()){
							//single file just take the new given filename
							newFilePath = newBasePath;
						} else {
							//directory case, use target directory and existing filenames!
							boost::filesystem::path filePath(meta[i].getFilename());
							newFilePath = newBasePath/filePath;
						}
						std::cout<<"[FileWrite] File: "<<newFilePath<<" is regular file with size: "<<meta[i].getFilesize()<<std::endl;
						std::ofstream fof(newFilePath.c_str(), std::ios::out | std::ifstream::binary);
						if(fof){
							std::streamsize fileSize = meta[i].getFilesize();

							if (fof.write(file.getDatastreamRef().data()+lastFile, fileSize))
							{
	//							std::cout<<"[FileWrite] Success writing file!"<<std::endl;
								lastFile+=fileSize;
							} else {
								std::cout<<" DONE -[FileWrite] Error writing file!"<<std::endl;
								answer.setSuccess(false);
								this->server->answer(id, answer);
								fof.close();
								return;
							}
							fof.close();
						} else {
							std::cout << " DONE - [FileWrite] Error could not open " << newFilePath.c_str() << "\n";
							answer.setSuccess(false);
							this->server->answer(id, answer);
							return;
						}

					}
				}
				answer.setSuccess(true);
			}
			catch (const boost::filesystem::filesystem_error& ex)
			{
				std::cout << ex.what() << '\n';
			}
			catch (...) {
				std::cout << "[FileWrite] Catch(...) Could not open " << request.getFilename() << "\n";
				answer.setSuccess(false);
			}

		}
		else
		{
			//request not valid
			std::cout<<"[FileWrite] ERROR requested file is not valid!"<<std::endl;
			answer.setSuccess(false);
		}

		std::cout<<" DONE - [FileWrite] File(s) written to disk --> sending answer"<<std::endl;
		this->server->answer(id, answer);

}
